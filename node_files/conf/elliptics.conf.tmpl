# log file
# set to 'syslog' without inverted commas if you want elliptics to log through syslog
log = <{node_config.working_dir}>files/logs/elliptics.log

# log level
# DNET_LOG_DATA		= 0
# DNET_LOG_ERROR	= 1
# DNET_LOG_INFO		= 2
# DNET_LOG_NOTICE	= 3
# DNET_LOG_DEBUG	= 4
log_level = 3 

# specifies whether to join storage network
join = 1

# config flags
# bits start from 0, 0 is unused (its actuall above join flag)
# bit 1 - do not request remote route table
# bit 2 - mix states before read operations according to state's weights
# bit 3 - do not checksum data on upload and check it during data read
# bit 4 - do not update metadata at all
# bit 5 - randomize states for read requests
flags = 16

# node will join nodes in this group
group = 2

# list of remote nodes to connect
#
# address:port:family where family is either 2 (AF_INET) or 10 (AF_INET6)
# address can be host name or IP
#
# It is possible to autodiscover remote clusters via multicast
# If you put 'autodiscovery:address:port:family' where address:port:family is valid multicast address,
# elliptics will broadcast information about itself and remote nodes with the same auth cookie will
# receive this information and connect to given node. Multicast TTL equals to 3.
remote = <{','.join([n + ":1025:2" for n in main_config.nodes])}>

# local address to bind to
# port 0 means random port
#
# one can use reserved word 'hostname' instead of local address (like hostname:1025:2)
# it will use hostname, the same as output of `hostname -f` command, as address
addr = <{node}>:1025:2

# wait timeout specifies number of seconds to wait for command completion
wait_timeout = 60

# this timeout specifies number of seconds to wait before killing
# unacked transaction
check_timeout = 60

# number of IO threads in processing pool
io_thread_num = 8

# number of IO threads in processing pool dedicated to nonblocking operations
# they are invoked from recursive commands like DNET_CMD_EXEC, when script
# tries to read/write some data using the same id/key as in original exec command
nonblocking_io_thread_num = 8

# number of thread in network processing pool
net_thread_num = 4

# specifies history environment directory
# it will host file with generated IDs
# and server-side execution scripts
history = <{node_config.working_dir}>files/history

# specifies whether to go into background
daemon = 0

# authentication cookie
# if this string (32 bytes long max) does not match to server nodes,
# new node can not join and serve IO
auth_cookie = qwerty

# Background jobs (replica checks and recovery) IO priorities
# ionice for background operations (disk scheduler should support it)
# class - number from 0 to 3
# 0 - default class
# 1 - realtime class
# 2 - best-effort class
# 3 - idle class
bg_ionice_class = 3
# prio - number from 0 to 7, sets priority inside class
bg_ionice_prio = 0

# IP priorities
# man 7 socket for IP_PRIORITY
# server_net_prio is set for all joined (server) connections
# client_net_prio is set for other connection
# is only turned on when non zero
server_net_prio = 1
client_net_prio = 6

# Size of operation lock hash table
# These locks guard command execution, they are grabbed for allmost all operations
# except recursive (for example when DNET_CMD_EXEC reads or writes data) and some
# maintenance commands like statistics gathering and route table update
# Recovery process also runs without locks grabbed, since this locks operation quite
# for a long period of time, which may interfere with clients IO
oplock_num = 10240

# SRW - server-side scripting section

# srw worker config
# Elliptics uses cocaine engine (https://github.com/organizations/cocaine) for its server-side workers
# srw_config should point to its configuration file, example config lives in tree in example/library_config.json file
srw_config = <{node_config.working_dir}>files/conf/cocaine.conf

# In-memory cache support
# This is maximum cache size. Cache is managed by LRU algorithm
# Using different IO flags in read/write/remove commands one can use it
# as cache for data, stored on disk (in configured backend),
# or as plain distributed in-memory cache
cache_size = 32212254720

# anything below this line will be processed
# by backend's parser and will not be able to
# change global configuration

backend = leveldb
#
# One may check discussion at http://www.ioremap.net/node/708/
#
# Sync in leveldb differs from what it is in all other backends
# 0 means no sync, while 1 means sync on every write
sync = 0

root = <{node_config.working_dir}>files/leveldb
log = <{node_config.working_dir}>files/logs/leveldb.log
cache_size = 100000
write_buffer_size = 100000
block_size = 4096
block_restart_interval = 8
compression = snappy

